<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>WebSocket Client</title>
	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			background-color: black;
			/* Set background color to black */
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
		}

		#fullscreen-button {
			position: absolute;
			top: 10px;
			left: 10px;
			z-index: 9999;
			padding: 10px;
			background-color: #000;
			color: white;
			border: 1px solid #fff;
			cursor: pointer;
		}
	</style>
</head>

<body>
	<canvas id="myCanvas"></canvas>
	<p id="info"></p>
	<button id="fullscreen-button">Fullscreen</button>

	<script>
		const socket = new WebSocket("wss://" + location.host);

		const messagesDiv = document.getElementById('messages');
		const info = document.getElementById('info');
		const canvas = document.getElementById('myCanvas');
		const ctx = canvas.getContext('2d');
		const fullscreenButton = document.getElementById('fullscreen-button');

		// Set canvas size to window size
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		// Event listener for WebSocket open
		socket.addEventListener('open', (event) => {
			console.log('WebSocket connection opened');
			info.textContent = 'WebSocket connection opened!';
		});

		socket.addEventListener('close', (event) => {
			console.log('WebSocket connection closed');
			info.textContent = 'WebSocket connection closed';
		});

		socket.addEventListener('error', (error) => {
			console.error('WebSocket error:', error);
		});

		// Function to send touch data to the server
		function sendTouchData(x, y, id) {
			if (socket.readyState !== WebSocket.OPEN) return;
			socket.send(`${Math.round(x)} ${Math.round(y)} ${Math.round(id)}\n`);
		}

		// Event listener for touch start, move, and end
		['touchstart', 'touchmove', 'touchend', 'touchcancel'].forEach(eventName => {
			canvas.addEventListener(eventName, (event) => {
				event.preventDefault();
				ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

				for (let i = 0; i < event.touches.length; i++) {
					const touch = event.touches[i];
					sendTouchData(touch.clientX, touch.clientY, touch.identifier);
					drawCircle(touch.clientX, touch.clientY, touch.identifier);
				}
			});
		});

		// Function to draw a circle at a given position with ID
		function drawCircle(x, y, id) {
			ctx.beginPath();
			ctx.arc(x, y, 20, 0, Math.PI * 2);
			ctx.fillStyle = 'blue';
			ctx.fill();
			ctx.closePath();

			ctx.fillStyle = 'blue';
			ctx.font = '16px Arial';
			ctx.textAlign = 'center';
			ctx.fillText(id, x, y + 60); // Adjust y coordinate to place text below the circle
		}

		// Fullscreen button functionality
		fullscreenButton.addEventListener('click', function () {
			if (document.fullscreenElement) {
				document.exitFullscreen();
				fullscreenButton.innerText = 'Fullscreen'; // Change button text back to 'Fullscreen'
			} else {
				if (document.body.requestFullscreen) {
					document.body.requestFullscreen();
					fullscreenButton.innerText = 'Exit Fullscreen'; // Change button text to 'Exit Fullscreen'
				}
			}
		});
	</script>
</body>

</html>